title: "Client Side Technology"
date: "2014-08-12T13:10:17-04:00"
comments: True
short: >
    I made a few toy websites recently with a wide range of tools that are are freely available for anyone to use.
    Read on to find out where this journey led me.
showInFeed: True
tags:
- blog
- website
- node.js
- css
- grunt
- flask

I made a few toy websites recently with a wide range of tools that are are freely available for anyone to use.
Read on to find out where this journey led me.

Preface
=======

At the time of posting, this current web domain was pushed using the [Flask][flask] web framework. 
The previous incarnation was made using the [Django][django] framework. 
In the future it is highly likely to be developed with numerous other technologies.

[Interface Zero][interfacezero]
===============================

Interface Zero is a pen and paper role play game in which you can create your own characters.
The idea was to make a website that is accessible on all devices which displays the stat sheets for multiple characters.

The stat sheets are full of numbers for ability values, names of weapons and notes for characters edges and hindrances.
A good fit for storing this in a human readable state is the [YAML][yaml] format.
Unfortunately it is not handle nativly in JavaScript, but library version of [js-yaml][js-yaml] can convert it to a [JSON][json] format at run time. 

The Flask framework has been used put together the [NathanRossPowell domain][nrp], but it is a fair bit of work and a machine that is correctly set up is needed to make edits and deploy the website. 
It is not ideal if the goal is to have a website which will display a small amount of data on a 'one page' website.

Using JavaScript (with jQuerey) it is trivial to dynamically append content to a section of HTML.
With the basic structure of the web page in orders, a JS file can loop over all of the stat sheets (which are in JSON format) and add body content and header navigation for each of them.
Writing out something to a string with gets added to a HTML element looks something like this:

    :::javascript
    var buildHtml = "";
    buildHtml += '<a class="anchor" id="' + contactsId(name) + '"></a>';
    // etc...
    $("#interfacezero-main").append(buildHtml)

The method is to append the dynamic values to a semi-formed HTML string and then add the closing element.
It is not a elegant method and it becomes very hard to read when nested elements are being created.
This method is also harder to debug.
Unlike static web page deploys, using the 'View Source' function of a browser does not show you what is being displayed on screen.
More advanced features of your browsers development tools will need to be used.
In [Google Chrome][chrome] the cursor should be placed on the HTML element of choice, then the right click menu will display and option to `inspect element`.
This will show all of the HTML that has been dynamically generated by the JavaScript functions.

Maintaining this code and adding new features can be painful.
Luckily once all of the values in the YAML stat sheets have been represented in HTML, there is not much to be done other than update the stat sheets as the role play campaign progresses.

The use of Github Pages means that collaborators can safely update a version controlled character sheet and then see the changes (almost) instantly due to the dynamic nature of the HTML generation.
Githubs extensive web interface controls mean that updating character sheets can done from any device.
Editing the files with a mobile device can be a bit tricky, but that is down to Githubs controls inside of their browser text editor.

Overall this project was a good learning experience and it highlights the need for some kind of HTML templating engine when dealing with dynamic values.

[YAML Boot Bars][yamlbootbars] & [French Quiz][frenchquiz]
==========================================================

There are a number of templating engines that are targeted at the HTML generation.
The [Jinja2][jinja2] template engine is the one employed by default in the [Flask][flask] framework.
A highly popular choice is the [Mustache][mustache] template system.
It is often seen as a 'base' for JavaScript templating and that idea is supported by the numerous forks and offshoots of the project such as [Handlebars][handlebars].
Handlebars adds lots of helpers to Mustache and is completely backwards compatible.

The [YAML Boot Bars][yamlbootbars] project was the next logical step from the Interface Zero project.
The Bootstrap styling and YAML data files where kept, but the dynamic HTML generation through JavaScript was replaced by the template engine.

### Dynamic Templates

Each Handlebars template is placed inline in the HTML document.
After everything is loaded the template is accessed using an `id` and a [JSON][json] object is formatted into it.

Here is an example taken from the test project [handlebar][nrp-handlebar].
The template code is contained in the `script` tag and it has a unique `id` of `shoe-template`:

    :::HTML
    <ul class="shoesNav">
      <script id="shoe-template" type="x-handlebars-template">
        {{#each this}}
          <li class="shoes"><a href="/{{name}}">{{name}} -- Price: {{price}} </a></li>
        {{/each}}
      </script>
    </ul>

That markup, as is, will not show anything when the HTML file is displayed.
To get the desired output the script element containing the template needs to be manipulated by the Handlebars JavaScript library.

    :::javascriot
    $(window).bind("load", function () {
        var shoesData = [
            {
                name :"Nike",
                price :199.00 
            }, 
            {
                name :"Loafers",
                price : 59.00 
            },
            {
                name : "Wing Tip",
                price : 259.00 
            }
        ];
        //Get the HTML from the template in the script tag
        var theTemplateScript = $("#shoe-template").html(); 
        //Compile the template
        var theTemplate = Handlebars.compile (theTemplateScript); 
        $(".shoesNav").append (theTemplate(shoesData)); 
    });

Here the JSON object `shoesData` is formatted into the template and the output is as expected.
A demo of this can be seen [here][nrp-handlebar-website]

### Compiled Templates

These templates are cleaner than generating HTML inside of JavaScript. 
With that said; not every website needs to have the 'live update' capabilities that the Interface Zero project required.
Formatting the template with the same JSON object on every reload is a waste of resources.

With a build step the templates can be formatted offline before being uploaded to the server which removes the need for run time JavaScript.
For previous projects where there was already a Python dependency, it would be a simple to put together a few scripts extra scripts (the Flask version of [nathanrosspowell.com][nrp] already has a script to do a static compile of the whole website).
For these projects a JavaScript solution was found

#### [Node.js][node] and [Grunt][grunt]




Assemble.io
===========

The future of my home page.

[interfacezero]: http://nathanrosspowell.com/code/interface-zero/ "Interface Zero code page"
[nrp]: http://nathanrosspowell.com "My home page"
[yaml]: http://yaml.org "YAML file format"
[jsyaml]: https://github.com/nodeca/js-yaml "JS-YAML - YAML 1.2 parser and serializer for JavaScript"
[json]: http://json.org/ "JSON (JavaScript Object Notation) is a lightweight data-interchange format"
[chrome]: https://www.google.com/chrome/browser "Google Chrome web browser"
[nrp-handlebar]: https://github.com/nathanrosspowell/handlebar
[nrp-handlebar-website]: http://nathanrosspowell.github.io/handlebar