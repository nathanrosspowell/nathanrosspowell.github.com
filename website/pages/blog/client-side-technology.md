title: "Client Side Technology"
date: "2014-08-12T13:10:17-04:00"
comments: True
short: >
    I made a few toy websites recently with a wide range of tools that are are freely available for anyone to use.
    Read on to find out where this journey led me.
showInFeed: True
tags:
- blog
- website
- node.js
- css
- grunt
- flask

I made a few toy websites recently with a wide range of tools that are are freely available for anyone to use.
Read on to find out where this journey led me.

Preface
=======

At the time of posting, this current web domain was pushed using the [Flask][flask] web framework. 
The previous incarnation was made using the [Django][django] framework. 
In the future it is highly likely to be developed with numerous other technologies.

[Interface Zero][interfacezero]
===============================

Interface Zero is a pen and paper role play game in which you can create your own characters.
The idea was to make a website that is accessible on all devices which displays the stat sheets for multiple characters.

The stat sheets are full of numbers for ability values, names of weapons and notes for characters edges and hindrances.
A good fit for storing this in a human readable state is the [YAML][yaml] format.
Unfortunately it is not handle nativly in JavaScript, but library version of [js-yaml][js-yaml] can convert it to a [JSON][json] format at run time. 

The Flask framework has been used put together the [NathanRossPowell domain][nrp], but it is a fair bit of work and a machine that is correctly set up is needed to make edits and deploy the website. 
It is not ideal if the goal is to have a website which will display a small amount of data on a 'one page' website.

Using JavaScript (with jQuerey) it is trivial to dynamically append content to a section of HTML.
With the basic structure of the web page in orders, a JS file can loop over all of the stat sheets (which are in JSON format) and add body content and header navigation for each of them.
Writing out something to a string with gets added to a HTML element looks something like this:

    :::javascript
    var buildHtml = "";
    buildHtml += '<a class="anchor" id="' + contactsId(name) + '"></a>';
    // etc...
    $("#interfacezero-main").append(buildHtml)

The method is to append the dynamic values to a semi-formed HTML string and then add the closing element.
It is not a elegant method and it becomes very hard to read when nested elements are being created.
This method is also harder to debug.
Unlike static web page deploys, using the 'View Source' function of a browser does not show you what is being displayed on screen.
More advanced features of your browsers development tools will need to be used.
In [Google Chrome][chrome] the cursor should be placed on the HTML element of choice, then the right click menu will display and option to `inspect element`.
This will show all of the HTML that has been dynamically generated by the JavaScript functions.

Maintaining this code and adding new features can be painful.
Luckily once all of the values in the YAML stat sheets have been represented in HTML, there is not much to be done other than update the stat sheets as the role play campaign progresses.

The use of Github Pages means that collaborators can safely update a version controlled character sheet and then see the changes (almost) instantly due to the dynamic nature of the HTML generation.
Githubs extensive web interface controls mean that updating character sheets can done from any device.
Editing the files with a mobile device can be a bit tricky, but that is down to Githubs controls inside of their browser text editor.

### Conclusion

Overall this project was a good learning experience and it highlights the need for some kind of HTML templating engine when dealing with dynamic values.

[YAML Boot Bars][yamlbootbars] & [French Quiz][frenchquiz]
==========================================================

These two projects are slightly different from each other, but the technology used to power them is exactly the same. [YAML Boot Bars][yamlbootbars] was intended to be a 'shell' of a project and [French Quiz][frenchquiz] is something that matched the same requirements.

There are a number of templating engines that are targeted at the HTML generation.
The [Jinja2][jinja2] template engine is the one employed by default in the [Flask][flask] framework.
A highly popular choice is the [Mustache][mustache] template system.
It is often seen as a 'base' for JavaScript templating and that idea is supported by the numerous forks and offshoots of the project such as [Handlebars][handlebars].
Handlebars adds lots of helpers to Mustache and is completely backwards compatible.

The [YAML Boot Bars][yamlbootbars] project was the next logical step from the Interface Zero project.
The Bootstrap styling and YAML data files where kept, but the dynamic HTML generation through JavaScript was replaced by the template engine.

### Dynamic Templates

Each Handlebars template is placed inline in the HTML document.
After everything is loaded the template is accessed using an `id` and a [JSON][json] object is formatted into it.

Here is an example taken from the test project [handlebar][nrp-handlebar].
The template code is contained in the `script` tag and it has a unique `id` of `shoe-template`:

    :::HTML
    <ul class="shoesNav">
      <script id="shoe-template" type="x-handlebars-template">
        {{#each this}}
          <li class="shoes"><a href="/{{name}}">{{name}} -- Price: {{price}} </a></li>
        {{/each}}
      </script>
    </ul>

That markup, as is, will not show anything when the HTML file is displayed.
To get the desired output the script element containing the template needs to be manipulated by the Handlebars JavaScript library.

    :::javascriot
    $(window).bind("load", function () {
        var shoesData = [
            {
                name :"Nike",
                price :199.00 
            }, 
            {
                name :"Loafers",
                price : 59.00 
            },
            {
                name : "Wing Tip",
                price : 259.00 
            }
        ];
        //Get the HTML from the template in the script tag
        var theTemplateScript = $("#shoe-template").html(); 
        //Compile the template
        var theTemplate = Handlebars.compile (theTemplateScript); 
        $(".shoesNav").append (theTemplate(shoesData)); 
    });

Here the JSON object `shoesData` is formatted into the template and the output is as expected.
A demo of this can be seen [here][nrp-handlebar-website]

### Compiled Templates

These templates are cleaner than generating HTML inside of JavaScript. 
With that said; not every website needs to have the 'live update' capabilities that the Interface Zero project required.
Formatting the template with the same JSON object on every reload is a waste of resources.

With a build step the templates can be formatted offline before being uploaded to the server which removes the need for run time JavaScript.
For previous projects where there was already a Python dependency, it would be a simple to put together a few scripts extra scripts (the Flask version of [nathanrosspowell.com][nrp] already has a script to do a static compile of the whole website).
For these projects a JavaScript solution was found

#### [Node.js][node] and [Grunt][grunt]

Node.js is a platform built around JavaScript which uses the Chrome V8 engine.
As well as allowing JavaScript to be used outside of the browser, with full access to the file system, Node.js offers a very rich community with access to thousands of libraries through the [Node Package Manager][npm].

Grunt is a task automation tool.
Adding a the file `Gruntfile.js` to a project allows tasks to be configured and run with a simple command line.

    :::bash
    grunt # Runs the default task
    grunt deploy # Runs the task set up to deploy the website

For these projects a large number of tasks where installed using [npm][npm].
These task are loaded in `Gruntfile.js` and configured with a JSON entry to specify the parameters for each individual task.

- [`grunt-compile-handlebars`][grunt-compile-handlebars] - Statically compile handlebars templates
- [`grunt-contrib-concat`][grunt-contrib-concat] - file concatenation
- [`grunt-contrib-copy`][grunt-contrib-copy] - file copy
- [`grunt-contrib-uglify`][grunt-contrib-uglify] - JavaScript minification
- [`grunt-file-append`][grunt-file-append] - file append
- [`grunt-gh-pages`][grunt-gh-pages] - commit and push deploy folder to another git branch
- [`grunt-jsbeautifier`][grunt-jsbeautifier] - JavaScript pretty print
- [`grunt-prettify`][grunt-prettify] - HTML pretty print
- [`grunt-replace`][grunt-replace] - find and replace 
- [`grunt-yaml`][grunt-yaml] - convert YAML to JSON

With all of these task configured the work flow for the two projects goes something like this:

1. YAML converted into JSON files in the `temp` directory
2. All JSON files concatenated into one JSON file, the key for each file being the file name (minus the extension)
3. All Handlebars files are compiled and copied to the `build` folder
4. All JavaScript files get minimized (if they are not `*.min.css`) and copied to the `build` folder
5. All remaining asset files are copied to the `build` folder

With the power of Grunt the projects have much more functionality than in the original goal, but the ease of setting up all of the task made it a no brainer.
The power of the open source community really shines when browsing the [npm][npm] listings.
It is simple to use someone elses solution instead of starting from scratch, as simple as one command line install and one JSON objects worth of configuration.

### Conclusion

These two projects have a completely custom set up and use a set of utilities rather than a web framework.
The setup is highly productive, but limited in scope some what.
For example, it would not be ideal to try and make a blogging site using this set up.

Node.js and Grunt turned out to be very impressive, so the next natural step is to look at fully fledged frameworks which also leverage them.

Assemble.io
===========

To Do....

[interfacezero]: http://nathanrosspowell.com/code/interface-zero/ "Interface Zero code page"
[nrp]: http://nathanrosspowell.com "My home page"
[yaml]: http://yaml.org "YAML file format"
[jsyaml]: https://github.com/nodeca/js-yaml "JS-YAML - YAML 1.2 parser and serializer for JavaScript"
[json]: http://json.org/ "JSON (JavaScript Object Notation) is a lightweight data-interchange format"
[chrome]: https://www.google.com/chrome/browser "Google Chrome web browser"
[nrp-handlebar]: https://github.com/nathanrosspowell/handlebar
[nrp-handlebar-website]: http://nathanrosspowell.github.io/handlebar
[flask]: http://flask.pocoo.org/ "Flask web micro framework"
[django]: https://www.djangoproject.com/ "Django web framework"
[js-yaml]: https://www.npmjs.org/package/js-yaml "js-yaml Node.js package"
[yamlbootbars]: https://github.com/nathanrosspowell/yaml-boot-bars " A YAML Bootstrap and Handlebars powered website"
[frenchquiz]: https://github.com/nathanrosspowell/frenchquiz "A French language resource"
[jinja2]: http://jinja.pocoo.org/docs/ "A Python templating engine"
[mustache]: http://mustache.github.io/ "A JavaScript templating engine"
[handlebars]: http://handlebarsjs.com/ "A JavaScript templating engine based on Mustache"
[node]: http://nodejs.org "Node.js is a platform built around JavaScript"
[grunt]: http://gruntjs.com/ "A JAvaScript task runner"
[npm]: https://www.npmjs.org "The Node Package Manager"
[grunt-compile-handlebars]: https://www.npmjs.org/package/grunt-compile-handlebars "Statically compile handlebars templates"
[grunt-contrib-concat]: https://www.npmjs.org/package/grunt-compile-handlebars "file concatination"
[grunt-contrib-copy]: https://www.npmjs.org/package/grunt-compile-copy "file copy"
[grunt-contrib-uglify]: https://www.npmjs.org/package/grunt-compile-uglify "JavaScript minification"
[grunt-file-append]: https://www.npmjs.org/package/grunt-file-append "file append"
[grunt-gh-pages]: https://www.npmjs.org/package/grunt-gh-pages "commit and push deploy folder to another git branch"
[grunt-jsbeautifier]: https://www.npmjs.org/package/grunt-jsbeautifier "JavaScript pretty print"
[grunt-prettify]: https://www.npmjs.org/package/grunt-prettify "HTML pretty print"
[grunt-replace]: https://www.npmjs.org/package/grunt-replace "find and replace"
[grunt-yaml]: https://www.npmjs.org/package/grunt-yaml "convert YAML to JSON"
